# Интерполяция и кривые Безье. Ее использование в разработке игр, анимации и создание плавных переходов от одних значений к другим

## Определение:
---
Интерполяция это математический метод нахождения неизвестных промежуточных значений между двумя или
более заданными значениями.

Интерполяция нашла широкое применение в анимации
(особенно пользовательских интерфейсов) и разработке игр, так как с её помощью можно плавно менять
числовые значения, например - позицию или размера объекта.

Давайте представим, что нам нужно переместить объект из точки  `a` в точку `b`.
Мы можем просто установить значение позиции объекта позицию `b`

``` c#
transform.position = b;
```

Но в таком случае переход будет резким и неестественным. На помощь приходит интерполяция,
которая позволяет рассчитать промежуточные значения между `a` и `b`, а не задавать,
например, 100 позиций между ними вручную, чтобы переход казался плавным.

## Линейная интерполяция:
---
`a` это наше начальное значение и в процентном соотношении равно 0,
а `b` - финальное значение и равно 1 (т.е. 100%).

Обозначим это процентное значение переменной `t`, которая будет находиться на промежутке [0; 1],
где при `t` = 0 значение будет соответствовать `a`, а при `t` = 1 соответствовать `b`.

Можем записать это в виде следующей формулы:

```
a + (b - a)t
```

Где `a` - начальное значение, `b` - конечное значение,
а `t` - значение прогресса,
которое находится в пределах от 0 до 1 включительно (т.е. от 0 до 100%).

Давайте создадим класс `Interpolations`, где реализуем метод линейной интерполяции

``` c#
public class Interpolations
{
    public static float Linear(float a, float b, float t)
    {
        if (t <= 0)
            return a;
        else if (t >= 1)
            return b;

        return a + (b - a) * t;
    }
}
```

Если мы вызовем `Interpolations.Linear(0, 5, 0.5f)`, то мы получим `2.5`,
что как раз и является средним значением между `a` и `b`.

Это и есть формула линейной интерполяции.

Вы могли быть знакомы с ней, если пользовались методами в Unity, которые называются Lerp (Расшифровывается, как Linear Interpolation) и принимают
в качестве аргументов те же самые параметры. 
Более того, эта формула равноценна вызову функции `Mathf.Lerp`

Эта интерполяция может быть выражена обычной прямой на графике, поэтому она и называется линейной.

![Изображение линейной интерполяции на графике](./img/linear_graph.png)

## Применение линейной интерполяции:
---
Интерполяция может быть применена к любым числовым значениям, поэтому мы без проблем можем добавить в наш класс
`Interpolations` аналог функции `Vector3.Lerp`, который будет
возвращать линейную интерполяцию между двумя векторами

``` c#
public class Interpolations
{
    public static float Linear(float a, float b, float t)
    {
        if (t &lt;= 0)
            return a;
        else if (t &gt;= 1)
            return b;

        return a + (b - a) * t;
    }

    public static Vector3 Linear(
      Vector3 a, 
      Vector3 b, 
      float t)
    {
        if (t <= 0)
            return a;
        else if (t >= 1)
            return b;

        return new Vector3(
          Linear(a.x, b.x, t), 
          Linear(a.y, b.y, t), 
          Linear(a.z, b.z, t)
        );
    }
}
```

Используя эту функцию линейной интерполяции в методе `Update` или в
`coroutine` можно добиться плавного передвижения объекта.

``` c#
private IEnumerator SmoothMove(Vector3 whereToMove)
{
    Vector3 startPosition = transform.position;
    float t = 0.0f;
    while (t &lt; 1.0f)
    {
        transform.position = Interpolations.Linear(
          startPosition, 
          whereToMove, 
          t);
        t += Time.deltaTime;
        yield return null;
    }
}
```

Если мы вызовем метод `StartCoroutine(SmoothMove(new Vector3(4, 0, 0)))`,
а после окончания посмотрим на позицию объекта в инспекторе, то можем заметить, что значения позиции не
соответствуют конечным.

![Значения не соответствуют конечным](./img/non_integer.png)

Почему же так? Из-за того, что значение `Time.deltaTime`,
которое мы прибавляем к `t` не является фиксированным
`t`, скорее всего, не будет равняться 1,
а остановится на значении близком к нему, например 0.98976.

Чтобы это исправить после цикла можно добавить задание конечного значение нашей изменяемой переменной.

``` c#
private IEnumerator SmoothMove(Vector3 whereToMove)
{
    Vector3 startPosition = transform.position;
    float t = 0.0f;
    while (t &lt; 1.0f)
    {
        transform.position = Interpolations.Linear(
          startPosition, 
          whereToMove, 
          t);
        t += Time.deltaTime;
        yield return null;
    }
    transform.position = whereToMove;
}
```

После этих изменений при окончании движения позиция объекта соответствует
финальным значениям, а мы получили плавную анимацию движения

![Линейная интерполяция объекта из одной точки в другую](./img/linear.gif)

Благодаря интерполяции можно плавно менять не только позицию объектов, а вообще любые числовые значения: размер, цвет, поворот и т.д.

Для большинства типов в Unity: `Vector2`,
`Vector3`, `Color`,
`Quaternion` и т.д. существует функция `Lerp`
(линейной интерполяции)

## Нелинейные виды интерполяции:
---

Интерполяция бывает не только линейной.
Так один из самых популярных нелинейных методов интерполяции `ease-in-out`
использует следующую формулу:

## **a - (b - a)t<sup>2</sup>(3 - 2t)**

и может быть представлен в виде трансформированной кубической параболы

![График ease-in-out интерполяции](./img/ease_graph.png)